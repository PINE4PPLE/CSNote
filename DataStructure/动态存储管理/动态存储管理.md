# 动态存储管理

​	已分配的地址连续的内存区称为"占用块"，未曾分配的地址连续的内存区称为"空闲块"。

| 分配策略         | 一                                         | 二                                           |
| ---------------- | ------------------------------------------ | -------------------------------------------- |
| 分配新内存的机制 | 从高地址的空闲块进行分配                   | 扫描内存区的所有空闲块并找到一个合适的空闲块 |
| 回收内存的时间   | 分配无法进行时(剩余空闲块不能满足分配请求) | 用户运行结束时                               |

系统需要构建一个记录所有空闲块的"可利用空间表"：结构可以是目录表，每个表项包含起始地址，内存块大小，使用情况；也可以是链表表中每个结点表示一个空闲块。

## 一、可利用空间表以及分配方法

可利用空间表根据系统的不同运行情况有嗓子不同的结构形式

| 情况 | 系统运行情况                               | 表结点类型           | 表结点的标志                               | 表类型                           |
| ---- | ------------------------------------------ | -------------------- | ------------------------------------------ | -------------------------------- |
| 1    | 所有用户请求分配的存储量大小相同。         | 固定大小的空闲块     | 链域(指向下一个表结点)；标志域(是否空闲)； | 链表                             |
| 2    | 所有用户请求分配的存储量大小有若干种规格。 | 若干固定大小的空闲块 | 链域；标志域；类型域（表结点大小）；       | 若干子链表，每个链表的表结点相同 |
| 3    | 所有用户请求分配的存储量大小不固定         | 空闲块大小不固定     | 链域；标志域；大小域；                     | 链表                             |

第一种情况的分配只需要将第一个结点分配给用户即可，回收时只需将用户释放的空闲块插入表头即可。

第二种情况的分配在对应链表不为空时与第一种情况类似，否则从较大链表中请求一个空闲块，分配对应的空间后将剩余空闲部分插入对应链表中；由于小空闲块的分配和回收会导致大空闲块被分割为小空闲块，需要执行"存储紧缩"操作将小空闲块合并为大空闲块。

第三种情况为操作系统中的可利用空间表，分配策略一般有三种：

|            | 空间表的有序性     | 分配策略                                                     | 回收策略                               | 应用场景                 |
| ---------- | ------------------ | ------------------------------------------------------------ | -------------------------------------- | ------------------------ |
| 首次拟合法 | 无序               | 从表头开始查找，将找到的第一个满足要求的空闲块的一部分分配给用户。 | 将释放的空闲块插入链表表头。           | 事先不知道运行期间的情况 |
| 最佳拟合法 | 空间块自小至大有序 | 将可利用空间表中一个满足要求且最接近的空闲块的一部分分配给用户。 | 将释放的空间块插入至链表合适的位置中。 | 内存大小范围较广         |
| 最差拟合法 | 空间块自大至小有序 | 从可利用空间表中满足要求且最大的空间块的一部分分配给用户。   | 将释放的空间块插入至链表合适的位置中。 | 内存大小范围较窄         |

## 二、边界标识法

边界表示法属于可利用空间表的第三种情况，为双重循环链表，分配策略可以是最佳拟合法，也可以是最差拟合法。特点是在内存区的头部和尾部分别设有标识，易于判断相邻内存区域是否为空闲

### 1.可利用空间表的结构

头部域有4个字段：llink, tag, size, rlink;

底部域有两个字段：uplink, tag;

```c
typedef struct WORD{
    union{
        WORD *llink;//头部域，指向前驱节点
        WORD *uplink//底部域：指向本结点头部
    };
    int tag;//头部域,底部域，是否被占用
    int size;//头部域，块大小
    WORD *rlink;//头部域，指向后继节点
    OtherType other;//字的其他部分
}Word, head, foot, *Space;

#define FootLoc(p) p+p->size-1
```

### 2.分配算法

假设采取首次拟合法，表头指针为pav，则由一下约定：

1. 假设用户请求空间为n字节，第一个满足条件的空闲块大小为m字节，选则一个常量$e$，若$m-n\le e$则将该块全部分配给用户，否则至分配n个字节，为避免修改指针，规定将节点高地址部分分配给用户。
2. 每次分配后使指针pav指向刚分配过的节点的后继节点，比米娜分配剩余的小块密集于一处。

```c
Space AllocBoundTag(Space &pav, int n){
    for(p = pav; p && p->size < n && p->rlink != pav; p = p->rlink);
    if(!p || p->size < n) return NULL;
    else{
        f = Footloc(p);
        pav = p->rlink;
        if(p->size - n <= e){
            if(pav == p) pav = NuLL;
            else{
                pav->llink = p->llink;
                p->llink->rlink = pav;
            }
            p->tag = p->tag = 1;
        }
        else{
            f->tag = 1;
            p->size -= n;
            f = Footloc(p);
            f->tag = 0;
            f->uplink = p;
            p = f + 1;
            p->tag = 1;
            p->size = n
        }
        return p;
    }
}
```

### 3. 回收算法

用户释放占用块时需要检查左右紧邻块是否为空闲块，若有空闲块则应将空闲块合并，否则直接插入空闲表中。

- 释放块左右均为占用块，此时只需要简单插入即可，插入位置任意。

  ```c
  p->tag = 0;
  Footloc(p)->uplink = p;
  Footloc(p)->tag = 0;
  if(!pav){
      pav = p->llink = p->rlink = p;
  }
  else{
      q = pav->llink;
      p->rlink = pav;
      pav->llink = p;
      p->llink = q;
      q->rlink = p;
      pav = p;
  }
  ```

- 释放块左邻区为空闲块，右邻区为占用块，需要将释放块与左邻区合并，只需改动左邻区的头部。

  ```c
  n = p->size;
  s = (p-1)->uplink;//左邻空闲块的头部
  s->size += n;//更新空闲块大小
  f = p + n - 1;
  f->tag = 0;
  f->uplink = s;//更新尾部指针
  ```

- 释放块右邻区为空闲块，左邻区为占用块，需要将释放块与左邻区合并，需要改动空闲块的头部以及链表的指针。

  ```c
  t = p + p->size;//右邻空闲节点
  p->tag = 0;
  q = t->llink;
  p->llink = q;
  p->rlink = p;
  q1 = t->rlink;
  q1->llink = p;
  p->rlink = q1;//更改链表
  p->size += t->size;//更新空闲块大小
  Footloc(p)->uplink = p;//底部指针指向新头部
  ```

  

- 释放块左、右邻区都为空闲块，需将三个块合并，块头部与链表指针需要改变。

  ```c
  n = p->size;//释放空间大小
  l = (p-1)->uplink;//左紧邻节点
  r = p + p->size;//右紧邻节点
  l->size += n + r->size;//更新空闲块大小
  q = r->llink;  q1 = r->rlink;
  q->rlink = q1;  q1->llink = q;//链表中删除右紧邻节点
  Footloc(s)->uplink = s;//空闲块底部指针指向新头部
  ```

## 三、伙伴系统

伙伴系统的特点是占用块和空闲块的大小均为2的k次幂。

### 1.可利用空间表的结构

为了再分配时查找方便，我们将大小相同的空闲块建于一张双重链表的子表中。可利用空间表为一个包含所有子表表头的向量表。

空间表的结点结构如下：

```c
#define m 16 //可利用空间总容量的对数，子表个数为m+1
typedef struct WORD_b{
    WORD_b *llink;//指向前驱结点
    int tag;//快标志 1占用，0空闲
    int kval;//块大小
    WORD_b *rlink;//头部域，指向后继节点
    OtherType other;//其他部分
}WORD_b, head;
typedef struct HeadNode{
    int nodesize;//链表空闲块大小
    WORD_b *first;//链表的表头指针
}FreeList[m+1];
```

### 2.分配算法

​		当用户提出大小为n的内存请求时，首先在可利用空间表中寻找结点大小与n相匹配的子表，若子表非空则将子表任意结点分配；否则从结点更大的非空子表中查找，直至找到一个空闲块，将其中一部分分配给用户，其余部分插入至相应子表中。

```c
WORD_b* AllocBuddy(FreeList &avail, int n){
    for(k = 0; k <= m && (avai[k].nodesize < n+1) || !(avail[k].first); ++k);
    //查找满足条件的子表
    if(k > m) return NULL;
    else{
        pa = avail[k].first;
        pre = pa->llink;
        suc = pa->rlnik;
        if(pa == suc) avail[k].first = NULL;
        else{
            pre->rlink = suc;
            suc->llink = pre;
            avail[k]->first = suc;
        }//将结点从子表中删除
        for(i = 1; avail[k-i].nodesize > n + 1; ++i){
            pi = pa + 2 ** (k - i);
            pi->rlink = pi;
            pi->llink = pi;
            pi->tag = 0;
            pi->kval = k - i;
            avail[k - i].first = pi;
        }//将剩余块添加至对应队列中
        pa->tag = 1;
        pa->kval = k - (--i);
    }
    return pa;
        
}
```

### 3.回收算法

伙伴系统中仅考虑互为"伙伴"的两个空闲块的归并。"伙伴"至的是由同一大块分裂出来的小块。

对起始地址为p，大小为$2^k$的内存块，其伙伴块的起始地址为：
$$
buddy(p,k) = 
\begin{cases}
p+2^k& p MOD 2^{k+1} = 0\\
p-2^k& p MOD 2^{k+1} = 2^k\\
\end{cases}
$$

```c
void insert(FreeList &avail, WORD_b* p){
    //给定空闲块将其插入对应子表中
    k = p->kval;
	for(i = 1; avail[i].nodesize != k; ++i);
    if(!avail[i].first){
        p->rlink = p->llink = p;
        avail[i].first = p;
    }
    else{
        q = avail[i].first;
        p->rlink = q;
        p->llink = q->llink;
        q->llink->rlink = p;
        q->llink = p;
        p->tag = 0;
        avail[i].first = p;
    }  
}

p % (2**(k + 1)) == 0? p + 2**k: p - 2**k;
if(buddy->tag == 1){
    insert(avail, p);
}//伙伴不为空闲块则直接插入
else{
    if(buddy->rlink == buddy){
        avail[i].first = NULL;
    }
    else{
        suc = buddy->rlink;
        pre = buddy->llink;
        suc->llink = pre;
        pre->rlink = suc;
        avail[i].first = suc;
    }//伙伴从对应子表中删除
    if(buddy < p){
        buddy->kval += 1;
        insert(avail, buddy);
    }
    else{
        p->val += 1;
        p->tag = 0;
        insert(avail, p);
    }
}//合并块之后插入至对应队列
```

## 四、无用单元收集

无用单元是指用户不再使用而系统没有回收的结构和变量。一方面，分配的空间未释放会导致无用单元从产生；另一方面，由于结构的某些特性也会产生无用单元，例如多个结构体的成员指向同一地址，释放某一个结构体时，由于共享的内存导致结构体无法被释放，产生无用单元。

解决方法由两种：

- 访问计数器：设置一个计数器，计数指向该内存的指针数目，当计数器值为0使释放内存。
- 收集无用单元：程序运行过程中不回收内存直至可利用空间表为空；此时暂时中断执行程序，将所有不被使用的内存连接在一起形成新的可利用空间表。

收集无用单元分为两步：一是对占用结点加上标志，二是扫描存储空间，将标志位为0的结点链接称一个新的可利用空间表。

标志算法有下面三种：

**1.递归算法**：递归地遍历整个广义表：若列表为空则无需遍历；若是一个数据元素则标志元素结点，否则首先标志表结点，在遍历表头和表尾。缺点是需要较大区域作为递归栈。

**2.非递归算法**：类似于广义优先遍历，或者二叉树的先序遍历，只需要一个内存较小的队列(栈)进行辅助，但所需的空间仍不确定。

**3.利用表结点本身的指针域标记遍历路径的算法**：

​		算法设定三个指针p、t、q：当p指向某个表结点时，t指向p的母结点，q指向p的表头或表尾。

​		当p指向表头时，有三种情况 

​		1. p的表头指示一个元素结点，则遍历表头只需对该表头结点打上标志后令q指向p的表尾。

​		2. p的表头为空表或已加上标志的子表，则只需令q指向p的表尾。

​		3. p的表头为未加标志的子表，则需先遍历头子表，即p所指结点的hp域值为t(保存t的值使得p能找到其母结			点)，p指向q，t指向p。

​		当p指向表尾时，有两种情况：

​		1.p的表尾为未加标志的子表，则需先便利表尾的子表，p所指结点的tp域值为t保存t的值使得p能找到其母结			点)，t指向p，p指向q。

​		2.p的表尾为空或已加上标志的子表：p回退至t，t回退至p的hp域或tp域(由tag域决定)。

```c
t = NULL; G = Gl; finished = false;
while(!finished){
    while(p->mark == 0){
        p->mark = 1;
        MarkHead(p);
    }//表头为未加标志的子表则修改指针记录路径，p指向表头；否则不变
    q = p->p.tp;
    if(q && q->mark == 0) MarkTail(p);//修改指针记录路径p指向表尾
    else BackTrack(finished);//若从表尾回溯至第一个结点则finished为true
}
```

```c
void Mark_List(GList GL){
    t = NULL; p = GL; finished = false;
    while(!finished){
        while(p->mark == 0){
            p->mark = 1;
       		q = q->p.hp;//q指向p表头
            if(q && q->mark ==0){
                if(q->tag == 0) q->mark = 1;//第一种情况
                else{
                    p->p.hp = t;
                    p->tag = 0;
                    t = p;
                    p = q;
                }//第三种情况
            }
            q = p->p.tp;//q指向p表尾
            if(q && q->mark == 0){
                p->p.tp = t;
                t = p;
                p = q;
            }//继续遍历表尾
            else{
                while(t&&t->tag == 1){//母结点为list，从表尾回溯
                    q = t;
                    t = q->q.tp;
                    q->q.tp = p;
                    p = q;
                }
                if(!t) finished =true;//结束
                else{//从表头回溯
                    q = t;
                    t = q->p.hp;
                    q->q.hp = p;
                    p = q;
                    p->tag = 1;
                }//继续遍历表尾
            }
        }
    }
}
```

## 五、存储紧缩

可利用空间是一个地址连续的存储区，称为"堆"。

**分配策略**：分配时从堆中划分一块。实现思路为：设置一个指针称为堆指针，始终指向堆的最低(或最高)地址。当用户申请N个单位的存储块时，堆指针向高地址(或低地址)移动N个单位，移动之前的堆指针地址为分配给用户的占用块的初始地址。

**回收策略**：需要执行存储紧缩将空闲块合并至堆中，执行时机有两种：用户释放后立即执行或直至可利用空间不足时才执行。

存储紧缩算法：

1. 计算占用块的新地址，双指针法。
2. 修改用户的初始变量表，使得用户程序能正常进行。
3. 检查每个占用块中方存储数据，若有指向其他存储块的指针则做出修改。
4. 将所有占用块迁移至新地址，即传送数据。