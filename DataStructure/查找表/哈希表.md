# 哈希表

## 一、哈希函数

​		**哈希函数**：在记录的存储位置和关键字之间的对应关系，记为f。则若记录中存在关键字和K相同的记录，则必定在f(K)的存储位置上。

​		哈希函数是一个映射，因此哈希函数的设定可以很灵活，只要使得任何关键字由此所得的哈希函数值都落在表长允许的范围之内即可。

​		一般情况下，哈希函数是一个压缩映射，因此必然存在**哈希冲突**，即不同关键字有同一哈希地址。#

### 哈希函数的构造方法

​		对关键字集合中任意一个关键字，经哈希函数映像到地址集合中任何一个地址的概率是相等的，则称此类哈希函数是**均匀**的。

#### 1.直接定址法

​		取关键字或关键字的某个线性函数数值为哈希地址，即
$$
H(key) = kry 或 H(key) = a\cdot key + b
$$
​		此类哈希函数称为自身函数。

#### 2.数字分析法

​		根据关键字的若干位数字组成哈希地址。

#### 3.平方取中法

​		取关键字平方后的中间几位为哈希地址。

#### 4.折叠法

​		将关键字分割成位数相同的几部分(最后一部分的位数可以不同)，然后取这几部分的叠加词作为哈希地址。

#### 5 .除留余数法

​		取一个关键字被某个不大于哈希表长m的数p除后所得余数为哈希地址，即
$$
H(key) = key\quad MOD \quad p,p\le m
$$

#### 6 .随机数法

​		选择一个随机函数，取关键字的随机函数值作为它的哈希地址。通常在关键字长度不等时采用词法构造哈希函数。

​		通常确定哈希函数的考虑因素有

1. 计算哈希函数所需的实践；
2. 关键字长度；
3. 哈希表的大小；
4. 关键字的分布情况；
5. 记录的查找频率；

## 二、处理冲突的方法

#### 1.开放定址法

$$
H_i = (H(key) + d_i) MODm,\quad i=1,2,\cdots,k(k\le m-1)
$$

其中。$H(key)$为哈希函数，m为哈希表表长，$d_i$为增量序列，可有三种取法：1，$d=1,2,\cdots,m-1$称为线性探测再散列；2，$d=1^2,-1^2,2^2,-2^2,\cdots,\pm k^2$，称为二次探测再散列；3，$d_i$为随机伪数列，称为随机探测再散列。

优点：只要哈希表未满，一定能找到不发生冲突的地址；计算方便；

缺点：“二次聚集”，处理同义词的冲突时又添加了非同义词的冲突。

#### 2.再哈希法

$$
H_i=RH_i(key),i=1,2,\cdots,k
$$

其中$RH_i$均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数的地址直至冲突不再发生。

优点：避免“二次聚集”。

缺点：增加计算量。

#### 3.链地址法

将所有关键字为同义词的记录存储在同一线性表中，假设某哈希函数产生的哈希地址在区间[0, m-1]上，则设立一个指针型向量。
$$
Chain \quad ChainHash[m]
$$

#### 4.建立一个公共溢出区

设哈希表为基本表，设立溢出表作为公共缓冲区，将所有关键字和基本表中关键字为同义词的记录填入溢出表中。

## 三、哈希表从查找及其分析

```c
int hashsize[] = {997,...};
typedef struct{
    ElemType *elem;//数据元素存储基址
    int count;//当前数据元素个数
    int sizeindex;//当前容量
}HashTable;

#define SUCCESS 1;
#define UNSUCCESS 0;
#define duplicate -1;

int SearchHash(HashTable H, KeyType K, int &p, int &c){
    //在开放定址的哈希表H中查找关键词为K的元素
    //查找成功则p返回待查数据在表中的位置，否则返回指示位置
    //c表示冲突次数
    p = Hash(K);//求K的哈希地址
    while(H.elem[p].key != null && !EQ(K, H.elem[p].key))//该位置已有记录且不相同
        collision(p, ++c);//求下一个探查地址p
    if(EQ(K, H.elem[p].key))
        return SUCCESS;
    else return UNSUCCESS;
}

int InsertHash(HashTable &H, ElemType e){
    c = 0;
    if(SearchHash(H, e.key, p, c))
        return DUPLICATE;//表中已有相同关键字的元素
    else if(c < hash[H.sizeindex]/2){//冲突次数小于设定值则插入
        H.elem[p] = e;
        ++H.count;
        return 1;
    }
    else{//否则重建哈希表
        RecreateHashTable(H);
        return UNSUCCESS;
    }
}
```

哈希表的装填因子定义为
$$
\alpha = \frac{表中填入记录数}{哈希表的长度}
$$
则线性探测再散列的哈希表查找成功时平均查找长度为
$$
S_{nl}\approx \frac{1}{2}(1+\frac{1}{1-\alpha})
$$
随机探测再散列，二次探测再散列和再哈希的哈希表查找成功时平均查找长度为
$$
S_{nr}\approx -\frac{1}{\alpha}ln(1-\alpha)
$$
链地址的哈希表查找成功时平均查找长度为
$$
S_nc\approx 1+\frac{\alpha}{2}
$$
